# intro

[[exercises]]
name = "intro1"
path = "exercises/intro/intro1.d"
hint = """Remove the 'Just D it' comment to move to the next exercise."""
type = "compile"

[[exercises]]
name = "intro2"
path = "exercises/intro/intro2.d"
hint = """
The format string expects something.
Add an argument inside the function."""
type = "compile"



# variables

[[exercises]]
name = "variables1"
path = "exercises/variables/variables1.d"
hint = """
When declaring variables, D needs a bit more information than just
an identifier. Try giving 'a' aditional information about what it is
and what it represents. Add the type before 'a'."""
type = "compile"

[[exercises]]
name = "variables2"
path = "exercises/variables/variables2.d"
hint = """
Unlike C or C++, all variables in D have predictable values when
initialized. This is because, by default, all variables are
initialized to their default initializer value. The int.init value
is '0'."""
type = "test"

[[exercises]]
name = "variables3"
path = "exercises/variables/variables3.d"
hint = """Add 'a = 4;' below the variable declaration."""
type = "test"

[[exercises]]
name = "variables4"
path = "exercises/variables/variables4.d"
hint = """
Variable 'a' is a constant value, so it cannot be modified. Remove
the assignment expression line."""
type = "compile"



# floating_point

[[exercises]]
name = "floating_point1"
path = "exercises/floating_point/floating_point1.d"
hint = """
Integer expressions cannot preserve the fractional part of a
result. Change the expected value '0.5' to '0'."""
type = "test"

[[exercises]]
name = "floating_point2"
path = "exercises/floating_point/floating_point2.d"
hint = """
The default initializer of floating point types is 'nan'. Arithmetic
operations with 'nan' always result in 'nan'. Initialize 'f' to any
numeric literal, e.g `float f = 0;`"""
type = "test"

[[exercises]]
name = "floating_point3"
path = "exercises/floating_point/floating_point3.d"
hint = """
Make use of the 'std.math' module. There you can find the 'isNan'
function and change the code to `assert(isNan(f));`"""
type = "compile"

[[exercises]]
name = "floating_point4"
path = "exercises/floating_point/floating_point4.d"
hint = """No hints this time ;)"""
type = "compile"



# functions

[[exercises]]
name = "functions1"
path = "exercises/functions/functions1.d"
hint = """Insert `a + b` after `return`."""
type = "compile"

[[exercises]]
name = "functions2"
path = "exercises/functions/functions2.d"
hint = """Insert the parameter `float a`, e.g `float half(float a)`"""
type = "compile"

[[exercises]]
name = "functions3"
path = "exercises/functions/functions3.d"
hint = """Insert the parameter `float a`, e.g `float half(float a)`"""
type = "compile"

[[exercises]]
name = "functions4"
path = "exercises/functions/functions4.d"
hint = """Create another function 'add' that receives 'float' types."""
type = "compile"

[[exercises]]
name = "functions5"
path = "exercises/functions/functions5.d"
hint = """
Modify the function signature to work with templated types.
`T multiply(T)(const T left, const T right)`"""
type = "compile"



# if

[[exercises]]
name = "if1"
path = "exercises/if/if1.d"
hint = """
Use an 'if' statement:
---
if (<condition>)
{
return <identifier>;
}
else
{
return <identifier>;
}
---

Note: The parentheses are optional in D for the `if` statement.
Note: without parenthesis only the first statement after `if` is
evaluated!"""
type = "test"

[[exercises]]
name = "if2"
path = "exercises/if/if2.d"
hint = """No hints this time ;)"""
type = "test"

[[exercises]]
name = "if3"
path = "exercises/if/if3.d"
hint = """Use the ternary operator, e.g `return a > b ? a : b;`"""
type = "test"



# quiz

[[exercises]]
name = "quiz1"
path = "exercises/quiz/quiz1.d"
hint = """No hints this time ;)"""
type = "test"
